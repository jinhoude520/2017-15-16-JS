<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    // 继承： 子类继承父类的方法；
//    var ary = [12,9,90];
    // Array
    //ary.__proto__ 找到父类原型上的方法

//    function A() {
//        this.welcome = function () {
//            console.log("欢迎你的到来");
//        }
//    };
//    A.prototype.sum= function () {
//        console.log(100)
//    };
//    var a = new A;
//    a.sum()
//    function B() {
//
//    }
//    B.prototype.s = function () {
//
//    }
    //B.prototype = A.prototype;// B的实例继承了类A的公有属性；B原型原有的方法也随之消失；
//    var b = new B;
//    b.sum();
//    b.welcome()// 报错； 不能继承类A的私有属性；
//    console.log(b.constructor);// A
//    B.prototype = new  A;// 把A的实例覆盖了类B的原型
//    var b = new  B;
//    b.welcome();
//    b.sum()
//  把类A的实例的空间赋值给类B的原型，那么类B的实例不仅可以调用类A的公有属性，还可以调用类A的实例的私有属性；这种继承方式就是原型继承；
    function B() {
        this.welcome = function () {
            console.log("欢迎你的到来");
        }
    };
    B.prototype = new  Array;
    var b = new B;
    b.pop();
</script>
</body>
</html>