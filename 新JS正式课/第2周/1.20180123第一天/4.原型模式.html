<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    function Fn() {// 自定义类；
        this.x = 100;
        this.y = 200;
//        this.sum = function () {
//            console.log(this.x + this.y)
//        }
    }
    Fn.prototype.x = 10;
    Fn.prototype.sum = function () {
        console.log(this.x + this.y)
    };
    //Fn();// this--->window;
    var f = new Fn;// {x:100,y:200,sum:function(){}}
    //f.sum();// 先找私有属性sum；私有属性存在，直接执行；// 300
    //    f.__proto__.sum()// NaN
    //f.to()// f.to  is  not  a function
    //
    console.log(f.sum === f.__proto__.sum);// true
    console.log(f.sum === Fn.prototype.sum);
    console.log(f.x === Fn.prototype.x);// true
    //    Fn.prototype.sum()// NaN
    console.log(f.__proto__ === Fn.prototype);// true f.__proto__和Fn.prototype指向同一个空间地址；


    // 原型
    // 1. 每一个函数数据类型（普通函数、类）都天生自带一个prototype属性，这是一个对象数据类型的值；
    // 2. prototype 的属性值中天生自带一个constructor属性，属性值指向当前原型所对应的那个类
    // 3.每一个对象数据类型（普通对象、数组、实例、prototype）都天生自带一个__proto__ 属性，属性值指向当前实例所属类的原型；

    //console.log(Fn.prototype instanceof Object);// true  ; 对象
    //    var obj = {al:12}
    //    obj.al
    //var  obj ={};// Object

    // 当获取对象的属性对应的属性值，先找私有属性，私有属性没有会通过__proto__ 继续向上查找，如果上级也没有，会继续通过原型中的__proto__向上查找，直到找到Object的原型为止，这个原型也不存在，则返回undefined；---》“原型链”


    // Object  :
    // toString : 转字符串




</script>
</body>
</html>